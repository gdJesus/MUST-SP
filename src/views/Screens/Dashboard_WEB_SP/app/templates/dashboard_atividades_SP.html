<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dashboard de Atividades</title>

    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.min.css">

    <!-- Google Fonts: Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <!-- Estilos personalizados -->
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            overflow-x: hidden;
        }

        /* --- Layout do Sidebar --- */
        .wrapper { display: flex; width: 100%; min-height: 100vh; align-items: stretch; }
        #sidebar {
            min-width: 280px; max-width: 280px; background: #212529;
            color: #fff; transition: all 0.3s;
        }
        #sidebar.active { margin-left: -280px; }
        #sidebar .sidebar-header {
            padding: 20px; background: #343a40; text-align: center;
            font-size: 1.5rem; font-weight: 700;
        }
        #sidebar .sidebar-controls { padding: 20px; }
        #sidebar .control-group { margin-bottom: 1.5rem; }
        #sidebar label { color: #adb5bd; font-weight: 500; margin-bottom: 0.5rem; }
        #sidebar .form-select, #sidebar .form-control {
            background-color: #343a40; color: #fff; border-color: #495057;
        }
        #sidebar .form-select:focus, #sidebar .form-control:focus {
            background-color: #343a40; color: #fff; border-color: #0d6efd; box-shadow: none;
        }
        #sidebar .form-select option { background: #343a40; color: #fff; }

        /* --- Layout do Conteúdo --- */
        #content { width: 100%; padding: 20px; min-height: 100vh; transition: all 0.3s; }
        #sidebar-toggle { font-size: 1.5rem; }
        .navbar-nav .nav-link { font-weight: 500; cursor: pointer; }
        .navbar-nav .nav-link.active { color: #0d6efd; font-weight: 700; }
        .tool-description { font-size: 0.9rem; color: #6c757d; margin-bottom: 1.5rem; } /* Estilo para descrições */

        @media (max-width: 768px) {
            #sidebar { margin-left: -280px; }
            #sidebar.active { margin-left: 0; }
            .navbar-title { display: none; }
        }

        /* --- Estilos dos Componentes --- */
        .card {
            border: none; border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        .file-upload-wrapper button { width: 100%; }
        .file-upload-wrapper { position: relative; overflow: hidden; display: block; }
        .file-upload-wrapper input[type=file] {
            font-size: 100px; position: absolute; left: 0; top: 0; opacity: 0; cursor: pointer;
        }
        .table-responsive { max-height: 550px; }
        #file-name {
            display: block; margin-top: 10px; color: #adb5bd; font-size: 0.875rem;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .loader-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255, 255, 255, 0.8); z-index: 9999;
            display: flex; justify-content: center; align-items: center;
        }
        .loader {
            border: 5px solid #f3f3f3; border-top: 5px solid #3498db; border-radius: 50%;
            width: 50px; height: 50px; animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .calendar-day.has-activity { background-color: #cfe2ff; cursor: pointer; font-weight: bold; }
        .calendar-day.selected-day { background-color: #0d6efd; color: white; border-radius: 0.25rem; }
        #modal-activity-details .badge { font-size: 0.9em; }

        .table-resizable { border-collapse: separate; border-spacing: 0; table-layout: fixed; width: 100%; }
        .table-resizable > thead > tr > th { position: relative; }
        .resizer { position: absolute; top: 0; right: 0; width: 5px; cursor: col-resize; user-select: none; height: 100%; }

        /* --- Estilos Kanban e Matrizes --- */
        .kanban-column, .analysis-column { /* Renomeado analysis-quadrant para column */
            background-color: #f8f9fa; border-radius: 0.5rem; padding: 10px;
            height: 100%; min-height: 400px; /* Aumenta altura mínima */ transition: background-color 0.2s;
        }
        .kanban-column.drag-over, .analysis-column.drag-over { background-color: #d1e7dd; } /* Feedback visual ao arrastar sobre */

        /* Cartão Kanban (Excel) e Item Manual (Matrizes) */
        .kanban-card, .manual-item {
            cursor: grab; background: #fff; border-left: 5px solid #6c757d;
            padding: 10px; margin-bottom: 8px; border-radius: 0.25rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .kanban-card:active, .manual-item:active { cursor: grabbing; }
        .kanban-card.dragging, .manual-item.dragging { opacity: 0.5; } /* Efeito ao arrastar */

        .analysis-column { min-height: 400px; }
        .column-title { /* Renomeado quadrant-title */
            font-weight: bold; border-bottom: 2px solid; padding-bottom: 5px; margin-bottom: 10px;
            display: flex; justify-content: space-between; align-items: center; /* Para alinhar título e botão + */
        }
        /* Estilos específicos Prós/Contras */
        .pros-column { background-color: #d1e7dd; } /* Verde claro */
        .contras-column { background-color: #f8d7da; } /* Vermelho claro */
        .pros-title { color: #0f5132; border-color: #0f5132; } /* Verde escuro */
        .contras-title { color: #842029; border-color: #842029; } /* Vermelho escuro */

        /* Item manual (usado em Eisenhower e Prós/Contras) */
        .manual-item {
             display: flex; justify-content: space-between; align-items: center;
        }
        .manual-item p { margin: 0; flex-grow: 1; margin-right: 10px; }
        .delete-item { cursor: pointer; color: #dc3545; } /* Cor vermelha para lixeira */
        .add-matrix-item { cursor: pointer; color: #0d6efd; } /* Cor azul para adicionar */
    </style>
</head>
<body>

    <div id="loader-overlay" class="d-none"><div class="loader"></div></div>

    <div class="wrapper">
        <!-- Sidebar -->
        <nav id="sidebar">
            <div class="sidebar-header"><h3>Controles</h3></div>
            <div class="sidebar-controls">
                <div class="control-group">
                    <label for="file-input">Arquivo</label>
                    <div class="file-upload-wrapper">
                        <button class="btn btn-primary" type="button"><i class="bi bi-upload me-2"></i> Carregar Excel</button>
                        <input type="file" id="file-input" accept=".xlsx, .xls, .csv"> <!-- Aceita CSV também -->
                    </div>
                    <span id="file-name">Nenhum arquivo.</span>
                </div>
                <div class="control-group">
                    <button id="export-button" class="btn btn-success w-100" disabled><i class="bi bi-download me-2"></i> Exportar Dados</button>
                </div>

                <h5 class="mt-4 pt-2 border-top border-secondary">Filtros</h5>
                <div class="control-group">
                    <label for="sheet-selector">Visão por Aba</label>
                    <select id="sheet-selector" class="form-select" disabled><option>Carregue um arquivo</option></select>
                </div>
                <div class="control-group">
                    <label for="responsavel-filter">Responsável</label>
                    <select id="responsavel-filter" class="form-select" disabled><option>Todos</option></select>
                </div>
                <div class="control-group">
                    <label for="status-geral-filter">Status Geral</label>
                    <select id="status-geral-filter" class="form-select" disabled>
                        <option value="Todos">Todos</option>
                        <option value="Pendente">Pendente</option>
                        <option value="Concluído">Concluído</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="ressalva-filter">Ressalvas</label>
                    <select id="ressalva-filter" class="form-select" disabled>
                        <option value="Todas">Todas</option>
                        <option value="Com Ressalvas">Com Ressalvas</option>
                        <option value="Sem Ressalvas">Sem Ressalvas</option>
                    </select>
                </div>
            </div>
        </nav>

        <!-- Page Content -->
        <div id="content">
            <nav class="navbar navbar-expand-lg navbar-light bg-light mb-4 p-2 rounded">
                <div class="container-fluid">
                    <button type="button" id="sidebar-toggle" class="btn btn-primary"><i class="bi bi-list"></i></button>
                    <h5 class="ms-3 my-0 fw-bold text-dark navbar-title">Dashboard de Atividades SP - ONS - PLC</h5>
                    <ul class="navbar-nav ms-auto d-flex flex-row">
                        <li class="nav-item"><a class="nav-link px-3" href="#" data-view="main-dashboard-view">Dashboard</a></li>
                        <li class="nav-item"><a class="nav-link px-3" href="#" data-view="kanban-view">Kanban Tarefas</a></li> <!-- Nome atualizado -->
                        <li class="nav-item"><a class="nav-link px-3" href="#" data-view="eisenhower-view">Matriz Eisenhower</a></li>
                        <li class="nav-item"><a class="nav-link px-3" href="#" data-view="swot-view">Prós e Contras</a></li> <!-- Nome atualizado -->
                    </ul>
                </div>
            </nav>

            <div id="dashboard-content">
                <!-- VISTA: DASHBOARD PRINCIPAL -->
                <div id="main-dashboard-view" class="view-container">
                     <h5 class="card-title fw-bold">Visão Geral das Atividades</h5>
                     <p class="tool-description">Visualize o status geral das atividades carregadas do arquivo Excel/CSV. Utilize os filtros laterais para refinar a visualização e os gráficos para identificar tendências e gargalos.</p>
                    <div id="dashboard-view-content" class="d-none"> <!-- Conteúdo escondido até carregar -->
                        <div class="row g-4 mb-4" id="stats-cards"></div>
                        <div class="row g-4 mb-4">
                            <!-- Gráficos -->
                            <div class="col-lg-4"><div class="card h-100"><div class="card-body d-flex flex-column"><h5 class="card-title fw-bold">Status Geral</h5><div class="flex-grow-1" style="position: relative; min-height: 250px;"><canvas id="statusChart"></canvas></div></div></div></div>
                            <div class="col-lg-4"><div class="card h-100"><div class="card-body d-flex flex-column"><h5 class="card-title fw-bold">Atividades c/ Ressalva</h5><div class="flex-grow-1" style="position: relative; min-height: 250px;"><canvas id="ressalvasChart"></canvas></div></div></div></div>
                            <div class="col-lg-4"><div class="card h-100"><div class="card-body d-flex flex-column"><h5 class="card-title fw-bold">Atividades por Responsável</h5><div class="flex-grow-1" style="position: relative; min-height: 250px;"><canvas id="responsavelChart"></canvas></div></div></div></div>
                        </div>
                        <div class="row g-4">
                            <div class="col-12"><div class="card h-100"><div class="card-body"><h5 class="card-title fw-bold">Detalhes da Atividade</h5><div id="data-table-container" class="table-responsive"></div></div></div></div>
                        </div>
                    </div>
                     <div id="initial-message" class="text-center p-5 bg-light rounded-3 mt-4"> <!-- Mensagem inicial exibida por padrão -->
                        <i class="bi bi-file-earmark-spreadsheet" style="font-size: 4rem; color: #6c757d;"></i>
                        <h3 class="mt-3">Aguardando arquivo...</h3>
                        <p class="text-muted">Use o menu lateral para carregar um arquivo Excel ou CSV para visualizar o Dashboard.</p>
                    </div>
                </div>

                <!-- VISTA: KANBAN TAREFAS (Conectado ao Excel) -->
                <div id="kanban-view" class="view-container d-none">
                    <div class="card">
                        <div class="card-body">
                             <h5 class="card-title fw-bold">Kanban Tarefas (Pendentes)</h5>
                             <p class="tool-description">Visualize as tarefas **pendentes** carregadas do Excel/CSV. Arraste os cartões entre as colunas para atualizar o status da tarefa (a mudança é salva no navegador e refletida no Dashboard/Exportação).</p>
                             <!-- Botão Adicionar removido daqui, pois é populado do Excel -->
                            <div id="kanban-excel-container"></div> <!-- Container específico para o Kanban do Excel -->
                        </div>
                    </div>
                </div>

                <!-- VISTA: MATRIZ EISENHOWER (Manual) -->
                <div id="eisenhower-view" class="view-container d-none">
                    <div class="card">
                        <div class="card-body">
                             <h5 class="card-title fw-bold">Matriz de Eisenhower (Manual)</h5>
                             <p class="tool-description">Priorize tarefas **manuais** com base nos eixos de Importante/Não Importante e Urgente/Não Urgente. Adicione, edite, remova e **arraste** itens entre os quadrantes.</p>
                            <div id="eisenhower-matrix-container"></div>
                        </div>
                    </div>
                </div>

                <!-- VISTA: PRÓS E CONTRAS (Manual) -->
                <div id="swot-view" class="view-container d-none">
                     <div class="card">
                        <div class="card-body">
                             <h5 class="card-title fw-bold">Análise de Prós e Contras (Manual)</h5>
                             <p class="tool-description">Liste pontos positivos e negativos **manualmente**. Adicione, edite, remova e **arraste** itens entre as colunas 'Prós' e 'Contras'.</p>
                            <div id="pros-cons-container"></div>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </div>

    <!-- Modal Calendário -->
    <div class="modal fade" id="calendarModal" tabindex="-1" aria-labelledby="calendarModalLabel" aria-hidden="true">
      <div class="modal-dialog modal-lg modal-dialog-centered">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="calendarModalLabel">Timeline da Atividade</h5>
            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
          </div>
          <div class="modal-body">
              <div id="calendar-container"></div>
              <hr>
              <div id="modal-activity-details" class="mt-3 p-3 bg-light rounded" style="max-height: 200px; overflow-y: auto;">Selecione um dia no calendário para ver os detalhes.</div>
          </div>
        </div>
      </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.2/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

    <script type="module">
        // --- CONSTANTES GLOBAIS ---
        const LOCAL_STORAGE_KEY = 'dashboardAppState_v4_kanban_excel'; // Chave atualizada

        // --- MODELO ---
        class DataModel {
            constructor() {
                this.excelData = { all: [], filtered: [], sheetNames: [], fileName: "Nenhum arquivo." };
                // Ferramentas manuais
                this.eisenhowerState = { important_urgent: [], important_not_urgent: [], not_important_urgent: [], not_important_not_urgent: [] };
                this.prosConsState = { pros: [], contras: [] };
            }

            // --- Métodos de Parse/Format/Cálculo ---
            parseDate(d){ if(d instanceof Date){ d.setHours(0,0,0,0); return d } if(typeof d === 'number' && d > 0){ try { const excelEpoch = new Date(Date.UTC(1899, 11, 30)); const date = new Date(excelEpoch.getTime() + d * 24 * 60 * 60 * 1000); if (!isNaN(date)) { date.setHours(0,0,0,0); return date; } } catch(e){ console.warn("Error parsing excel date number", e); } } if("string"!=typeof d||""===d.trim())return null; const t=d.trim(); let e=null; let a=t.match(/^(\d{4})[-/](\d{1,2})[-/](\d{1,2})$/); if(a)e=new Date(parseInt(a[1]),parseInt(a[2])-1,parseInt(a[3])); else if(a=t.match(/^(\d{1,2})[-/](\d{1,2})[-/](\d{4})$/)){ const n=parseInt(a[1]),s=parseInt(a[2]),i=parseInt(a[3]); e=n>12?new Date(i,s-1,n):new Date(i,s-1,n) } return e&&!isNaN(e.getTime())?(e.setHours(0,0,0,0),e):null }
            formatDate(d){ return d instanceof Date&&!isNaN(d.getTime())?d.toLocaleDateString("pt-BR",{day:'2-digit', month:'2-digit', year:'numeric'}):"" }
            calculateWorkdays(d){ if(!(d instanceof Date)||isNaN(d.getTime()))return null; let t=new Date; t.setHours(0,0,0,0); if(d.getTime()===t.getTime())return 0; let e=0,a=new Date(t); if(d>t){ a.setDate(a.getDate()+1); for(;a<=d;){ const n=a.getDay(); 0!==n&&6!==n&&e++,a.setDate(a.getDate()+1) } }else for(;a>d;){ a.setDate(a.getDate()-1); const s=a.getDay(); 0!==s&&6!==s&&e-- } return e }

            // Carrega dados do arquivo Excel/CSV
             async loadWorkbook(file) {
                 console.log(`Loading workbook: ${file.name}`);
                 const data = await file.arrayBuffer();
                 let workbook;
                 let isCSV = file.name.toLowerCase().endsWith('.csv');

                 try { // Leitura do arquivo
                     if (isCSV) {
                         const textDecoder = new TextDecoder('utf-8'); let csvText = textDecoder.decode(data);
                         if (!/[\u00C0-\u017F]/.test(csvText)) {
                            try { const latin1Decoder = new TextDecoder('iso-8859-1'); csvText = latin1Decoder.decode(data); console.log("Decoded CSV as iso-8859-1"); } catch { console.warn("Failed decode as iso-8859-1"); }
                         } else { console.log("Decoded CSV as utf-8"); }
                         workbook = XLSX.read(csvText, { type: 'string', raw: true });
                     } else {
                         workbook = XLSX.read(data, { type: 'array', cellDates: true }); console.log("Decoded Excel file");
                     }
                 } catch (error) { console.error("Error reading file:", error); throw new Error("Não foi possível ler o arquivo."); }

                this.excelData.sheetNames = workbook.SheetNames;
                this.excelData.fileName = file.name;
                console.log(`Sheets found: ${this.excelData.sheetNames}`);

                // Processa os dados
                const newAllData = [];
                this.excelData.sheetNames.forEach(name => {
                    const worksheet = workbook.Sheets[name]; if (!worksheet) return;
                    let sheetData;
                    try { sheetData = XLSX.utils.sheet_to_json(worksheet, { raw: false, defval: "", dateNF:'dd/mm/yyyy'}); }
                    catch (error) { console.error(`Error processing sheet "${name}":`, error); alert(`Erro ao processar aba "${name}".`); return; }

                    sheetData.forEach((row, index) => {
                        const findKey = (p) => { for (const n of p) { for (const c in row) { if (c && c.trim().toLowerCase() === n.toLowerCase()) return c; } } return null; };
                        const atividadeKey = findKey(['atividade', 'atividades', 'descrição', 'description', 'task']);
                        const responsavelKey = findKey(['responsável', 'responsavel', 'owner', 'assigned to']);
                        const previsaoKey = findKey(['previsão de término', 'previsao de termino', 'prazo', 'due date', 'data final']);
                        const observacaoKey = findKey(['observação', 'observacao', 'obs', 'comments', 'notas', 'notes']);
                        const statusKey = findKey(['status', 'situação', 'situacao']);
                        const tempoTotalKey = findKey(['tempo total']);

                        const newRow = { ID: `${name.replace(/[^a-zA-Z0-9]/g, '')}-${index}`, ORIGEM: name };
                        let statusValue = statusKey ? String(row[statusKey] || '').trim().toLowerCase() : '';
                        const concluidoTerms = ['concluído', 'concluido', 'feito', 'ok', 'finalizado', 'concluded', 'done'];
                        newRow.STATUS = (!statusValue && name.toLowerCase().includes('concluído')) || concluidoTerms.some(term => statusValue.includes(term)) ? 'Concluído' : 'Pendente';
                        newRow.dueDate = this.parseDate(previsaoKey ? row[previsaoKey] : null);
                        newRow['PREVISÃO DE TÉRMINO_FORMATADA'] = this.formatDate(newRow.dueDate);
                        newRow['DIAS ÚTEIS'] = newRow.dueDate ? this.calculateWorkdays(newRow.dueDate) : '';
                        newRow['ATIVIDADES'] = atividadeKey ? row[atividadeKey] || '' : `Item ${index+1}`;
                        newRow['RESPONSÁVEL'] = responsavelKey ? row[responsavelKey] || '' : '';
                        newRow['OBSERVAÇÃO'] = observacaoKey ? row[observacaoKey] || '' : '';
                        newRow['TEMPO TOTAL'] = tempoTotalKey ? row[tempoTotalKey] || '' : '';
                        newAllData.push(newRow);
                    });
                    console.log(`Processed sheet "${name}", added ${sheetData.length} rows.`);
                });
                this.excelData.all = newAllData;
                console.log("Workbook loading finished.");
            }


            // Aplica os filtros selecionados aos dados do Excel
            applyFilters({ sheet, responsible, status, ressalva }) {
                console.log("Applying filters:", { sheet, responsible, status, ressalva });
                let data = [...this.excelData.all];
                if (sheet && sheet !== 'Consolidado') data = data.filter(r => r.ORIGEM === sheet);
                if (responsible && responsible !== 'Todos') data = data.filter(r => r['RESPONSÁVEL'] === responsible);
                if (status === 'Pendente') data = data.filter(r => r.STATUS === 'Pendente');
                if (status === 'Concluído') data = data.filter(r => r.STATUS === 'Concluído');
                if (ressalva === 'Com Ressalvas') data = data.filter(r => r['OBSERVAÇÃO'] && String(r['OBSERVAÇÃO']).trim() !== '');
                if (ressalva === 'Sem Ressalvas') data = data.filter(r => !r['OBSERVAÇÃO'] || String(r['OBSERVAÇÃO']).trim() === '');
                this.excelData.filtered = data;
                console.log(`Filtering complete. ${this.excelData.filtered.length} rows remaining.`);
            }

            // Calcula estatísticas para os cards (baseado nos dados filtrados do Excel)
            getStats() {
                const data = this.excelData.filtered;
                const total = data.length;
                const comRessalvas = data.filter(r => r['OBSERVAÇÃO'] && String(r['OBSERVAÇÃO']).trim() !== '').length;
                const statusCounts = { pendente: data.filter(r => r.STATUS === 'Pendente').length, concluido: data.filter(r => r.STATUS === 'Concluído').length };
                const respChartData = {};
                data.forEach(r => {
                    const resp = r['RESPONSÁVEL'] || 'Não atribuído';
                    if (!respChartData[resp]) respChartData[resp] = { 'Pendente': 0, 'Concluído': 0 };
                    if (r.STATUS === 'Pendente' || r.STATUS === 'Concluído') { respChartData[resp][r.STATUS]++; }
                });
                return { total, responsibleCount: new Set(data.map(r => r['RESPONSÁVEL']).filter(Boolean)).size, ressalvas: { com: comRessalvas, sem: total - comRessalvas }, statusCounts, respChartData };
            }

            // Retorna dados para o Kanban (apenas tarefas pendentes do Excel filtrado)
             getKanbanExcelData() {
                 const tasks = this.excelData.filtered.filter(task => task.STATUS === 'Pendente');
                 // Separa as tarefas pendentes pela categoria salva (se existir)
                 const groupedTasks = { todo: [], inprogress: [], done: [] }; // done sempre vazio aqui
                 tasks.forEach(task => {
                     const category = task._kanbanCategory || 'todo'; // Default 'todo'
                     if (groupedTasks[category]) {
                         groupedTasks[category].push(task);
                     } else {
                         groupedTasks.todo.push(task); // Fallback para 'todo' se categoria inválida
                     }
                 });
                 console.log("Grouped Kanban Excel data:", groupedTasks);
                 return groupedTasks;
             }


            // Obtém dados para as matrizes MANUAIS
            getAnalysisData() {
                return {
                    eisenhower: this.eisenhowerState,
                    prosCons: this.prosConsState
                };
            }

            // Obtém atividades do Excel de um mês específico (para o modal calendário)
            getActivitiesForMonth(date) {
                const year = date.getFullYear(), month = date.getMonth();
                return this.excelData.filtered.filter(r => r.dueDate && r.dueDate.getFullYear() === year && r.dueDate.getMonth() === month);
            }

            // Retorna lista única de responsáveis (baseado em todos os dados do Excel)
            getUniqueResponsibles() { return [...new Set(this.excelData.all.map(r => r['RESPONSÁVEL']).filter(Boolean))].sort(); }

             // --- Métodos para ATUALIZAR ESTADO ---

             // Atualiza o STATUS de uma tarefa do Excel (na memória)
            updateExcelActivityStatus(itemId, newStatus, newKanbanCategory = null) {
                let changed = false;
                let itemFound = null;
                // Atualiza em allData
                const itemAll = this.excelData.all.find(item => item.ID === itemId);
                if (itemAll) {
                    itemFound = itemAll; // Guarda a referência
                    if (itemAll.STATUS !== newStatus) {
                        itemAll.STATUS = newStatus;
                        console.log(`Updated status in allData for ${itemId} to ${newStatus}`);
                        changed = true;
                    }
                    // Guarda a categoria do Kanban DENTRO do objeto da tarefa
                    // Isso ajuda a lembrar onde ela estava no Kanban se os filtros mudarem
                    if (newKanbanCategory && newStatus === 'Pendente') { // Só salva categoria se for Pendente
                        itemAll._kanbanCategory = newKanbanCategory;
                        console.log(`Set _kanbanCategory=${newKanbanCategory} for ${itemId}`);
                    } else {
                        // Se virou concluído ou não tem categoria, remove a propriedade
                        delete itemAll._kanbanCategory;
                         console.log(`Removed _kanbanCategory for ${itemId}`);
                    }
                }
                // Atualiza em filteredData (se existir lá)
                const itemFiltered = this.excelData.filtered.find(item => item.ID === itemId);
                 if (itemFiltered) {
                    if (itemFiltered.STATUS !== newStatus) {
                        itemFiltered.STATUS = newStatus;
                        console.log(`Updated status in filteredData for ${itemId} to ${newStatus}`);
                        changed = true; // Garante que é true se mudou aqui
                    }
                    if (newKanbanCategory && newStatus === 'Pendente') {
                        itemFiltered._kanbanCategory = newKanbanCategory;
                    } else {
                        delete itemFiltered._kanbanCategory;
                    }
                 }

                if (changed) this.saveState(); // Salva se houve mudança
                return changed;
            }

            // Adiciona item manual (Eisenhower ou ProsCons)
            addManualItem(toolType, category, itemText) {
                const state = toolType === 'eisenhower' ? this.eisenhowerState : this.prosConsState;
                const newItem = { id: `manual-${toolType}-${Date.now()}`, text: itemText };
                if (!state[category]) { state[category] = []; }
                state[category].push(newItem);
                console.log(`Added item to ${toolType}/${category}`);
                this.saveState();
            }

            // Remove item manual (Eisenhower ou ProsCons)
            removeManualItem(toolType, category, itemId) {
                const state = toolType === 'eisenhower' ? this.eisenhowerState : this.prosConsState;
                if (state[category]) {
                    const initialLength = state[category].length;
                    state[category] = state[category].filter(item => item.id !== itemId);
                    if(state[category].length < initialLength) {
                         console.log(`Removed item ${itemId} from ${toolType}/${category}`);
                         this.saveState();
                         return true;
                    }
                }
                 console.warn(`Item ${itemId} not found in ${toolType}/${category}`);
                 return false;
            }

            // Atualiza texto de item manual (Eisenhower ou ProsCons)
            updateManualItem(toolType, itemId, newText) {
                const state = toolType === 'eisenhower' ? this.eisenhowerState : this.prosConsState;
                 for (const category in state) {
                     const item = state[category].find(i => i.id === itemId);
                     if (item) {
                         if (item.text !== newText) {
                            item.text = newText;
                            console.log(`Updated item ${itemId} text in ${toolType}/${category}`);
                            this.saveState();
                         }
                         return true;
                     }
                 }
                 console.warn(`Item ${itemId} not found in ${toolType} state for update`);
                 return false;
            }

             // Move item manual ENTRE categorias/quadrantes (Eisenhower ou ProsCons)
            moveManualItem(toolType, itemId, targetCategory) {
                 const state = toolType === 'eisenhower' ? this.eisenhowerState : this.prosConsState;
                 let itemToMove = null;
                 let oldCategory = null;
                 // Encontra e remove da categoria antiga
                 for(const category in state) {
                     if (!state[category]) continue; // Pula se categoria não existe ou está vazia
                    const index = state[category].findIndex(item => item.id === itemId);
                    if (index !== -1) {
                        itemToMove = state[category].splice(index, 1)[0];
                        oldCategory = category;
                        break;
                    }
                 }
                 // Adiciona na nova categoria
                 if (itemToMove) {
                    if (!state[targetCategory]) { state[targetCategory] = []; }
                    state[targetCategory].unshift(itemToMove); // Adiciona no início
                    console.log(`Moved manual item ${itemId} from ${oldCategory} to ${targetCategory} in ${toolType}`);
                    this.saveState();
                    return true;
                 }
                 console.warn(`Manual item ${itemId} not found for moving in ${toolType}.`);
                 return false;
            }


             // Salva o estado atual no localStorage
             saveState() {
                try {
                    const stateToSave = {
                        // Salva infos do Excel E os dados processados (allData) com status atualizados
                        excelData: {
                             sheetNames: this.excelData.sheetNames,
                             fileName: this.excelData.fileName,
                             all: this.excelData.all // Salva os dados com status potencialmente modificados
                        },
                        // Salva o estado das ferramentas manuais
                        eisenhowerState: this.eisenhowerState,
                        prosConsState: this.prosConsState
                    };
                    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(stateToSave));
                    console.log("Application state saved to localStorage.");
                } catch (e) {
                    console.error("Error saving state to localStorage:", e);
                }
            }

             // Carrega o estado do localStorage
            loadState() {
                const savedState = localStorage.getItem(LOCAL_STORAGE_KEY);
                if (savedState) {
                    try {
                        const parsedState = JSON.parse(savedState);
                        console.log("Loading state from localStorage:", parsedState);

                        // Restaura estado das ferramentas manuais
                        this.eisenhowerState = parsedState.eisenhowerState || { important_urgent: [], important_not_urgent: [], not_important_urgent: [], not_important_not_urgent: [] };
                        this.prosConsState = parsedState.prosConsState || { pros: [], contras: [] };

                        // Restaura informações E dados do último arquivo Excel
                        if (parsedState.excelData && parsedState.excelData.all) {
                            this.excelData.sheetNames = parsedState.excelData.sheetNames || [];
                            this.excelData.fileName = parsedState.excelData.fileName || "Nenhum arquivo.";
                            // Recria objetos Date a partir das strings ou timestamps salvos
                            this.excelData.all = parsedState.excelData.all.map(row => ({
                                ...row,
                                dueDate: row.dueDate ? new Date(row.dueDate) : null // Converte de volta para Date
                            }));
                             // Atualiza o nome do arquivo na UI (mas só o nome)
                             const fileNameEl = document.getElementById('file-name');
                             if (fileNameEl) fileNameEl.textContent = this.excelData.fileName;

                             console.log(`Restored ${this.excelData.all.length} rows from saved Excel data.`);
                        } else {
                             console.log("No saved Excel data found in localStorage state.");
                             this.excelData = { all: [], filtered: [], sheetNames: [], fileName: "Nenhum arquivo." };
                        }

                        console.log("State loaded successfully.");
                        return true; // Indica que um estado (pelo menos parcial) foi carregado

                    } catch (e) {
                        console.error("Error parsing saved state from localStorage:", e);
                        localStorage.removeItem(LOCAL_STORAGE_KEY); // Limpa estado inválido
                        this.excelData = { all: [], filtered: [], sheetNames: [], fileName: "Nenhum arquivo." }; // Reseta
                        return false;
                    }
                }
                console.log("No saved state found in localStorage.");
                this.excelData = { all: [], filtered: [], sheetNames: [], fileName: "Nenhum arquivo." }; // Garante reset se não houver state
                return false; // Nenhum estado salvo encontrado
            }
        }

        // --- VISÃO (View) ---
        class DashboardView {
            constructor() {
                this.getElements(); // Busca elementos do DOM
                this.charts = {}; // Armazena instâncias dos gráficos
            }

            // Busca e atribui elementos do DOM
            getElements() {
                Object.assign(this, {
                    loader: document.getElementById('loader-overlay'),
                    sidebar: document.getElementById('sidebar'),
                    sidebarToggle: document.getElementById('sidebar-toggle'),
                    fileNameEl: document.getElementById('file-name'),
                    sheetSelector: document.getElementById('sheet-selector'),
                    responsavelFilter: document.getElementById('responsavel-filter'),
                    statusGeralFilter: document.getElementById('status-geral-filter'),
                    ressalvaFilter: document.getElementById('ressalva-filter'),
                    dashboardContent: document.getElementById('dashboard-content'),
                    initialMessage: document.getElementById('initial-message'), // Msg inicial no Dashboard
                    dashboardViewContent: document.getElementById('dashboard-view-content'), // Conteúdo real do Dashboard
                    statsCardsContainer: document.getElementById('stats-cards'),
                    dataTableContainer: document.getElementById('data-table-container'),
                    statusChartCanvas: document.getElementById('statusChart'),
                    ressalvasChartCanvas: document.getElementById('ressalvasChart'),
                    responsavelChartCanvas: document.getElementById('responsavelChart'),
                    exportButton: document.getElementById('export-button'),
                    // Containers das ferramentas
                    kanbanExcelContainer: document.getElementById('kanban-excel-container'), // Kanban (Excel)
                    eisenhowerContainer: document.getElementById('eisenhower-matrix-container'), // Eisenhower (Manual)
                    prosConsContainer: document.getElementById('pros-cons-container'), // Pros/Cons (Manual)
                });
                 // Checa se elementos essenciais foram encontrados
                 if (!this.dashboardContent || !this.initialMessage || !this.dashboardViewContent) {
                     console.error("Elementos essenciais do DOM (dashboardContent, initialMessage ou dashboardViewContent) não encontrados!");
                 }
            }


            // Mostra/Esconde o overlay de carregamento
            toggleLoading(show) { if(this.loader) this.loader.classList.toggle('d-none', !show); }

            // Habilita/Desabilita a interface principal (Dashboard) vs inicial
             toggleDashboardContentVisibility(show) {
                 if (this.dashboardViewContent) this.dashboardViewContent.classList.toggle('d-none', !show);
                 if (this.initialMessage) this.initialMessage.classList.toggle('d-none', show);
                 // Habilita exportação se houver dados OU se ferramentas manuais tiverem algo (lógica no controller)
                 // if (this.exportButton) this.exportButton.disabled = !show;
            }

            // Atualiza o nome do arquivo exibido no sidebar
            updateFileName(name) { if(this.fileNameEl) this.fileNameEl.textContent = name; }

            // Popula os seletores de filtro com opções
            populateFilters(sheetNames, responsibles) {
                 if (!this.sheetSelector || !this.responsavelFilter) return;
                 this.sheetSelector.innerHTML = '<option value="Consolidado">Consolidado</option>';
                 this.responsavelFilter.innerHTML = '<option value="Todos">Todos</option>';

                 (sheetNames || []).forEach(n => { const o=document.createElement('option');o.value=n;o.textContent=n;this.sheetSelector.appendChild(o); });
                 (responsibles || []).forEach(r => { const o=document.createElement('option');o.value=r;o.textContent=r;this.responsavelFilter.appendChild(o); });

                 // Habilita os filtros baseado na presença de sheetNames (indica que um arquivo foi carregado)
                 const hasData = sheetNames && sheetNames.length > 0;
                 [this.sheetSelector, this.responsavelFilter, this.statusGeralFilter, this.ressalvaFilter].forEach(el => {
                     if(el) el.disabled = !hasData;
                 });
            }


            // Renderiza os cards de estatísticas
            renderStatsCards({ total, responsibleCount }) {
                if (!this.statsCardsContainer) return;
                this.statsCardsContainer.innerHTML = `
                    <div class="col-sm-6 col-lg-6"><div class="card"><div class="card-body"><h5>Total Atividades (Visão)</h5><h2 class="fw-bold">${total}</h2></div></div></div>
                    <div class="col-sm-6 col-lg-6"><div class="card"><div class="card-body"><h5>Responsáveis (Visão)</h5><h2 class="fw-bold">${responsibleCount}</h2></div></div></div>`;
            }

             // Renderiza o Kanban conectado ao Excel
             renderKanbanExcel(tasksByStatus, handlers) { // Recebe tarefas já separadas por status do controller
                 if (!this.kanbanExcelContainer) return;
                 const config = { todo: { t: 'A Fazer' }, inprogress: { t: 'Em Andamento' }, done: { t: 'Concluído' } };
                 let html = '<div class="row g-3">';

                 for (const key in config) {
                     // As tarefas já vêm agrupadas corretamente pelo controller
                     const tasks = tasksByStatus[key] || [];
                     html += `<div class="col-lg-4 col-md-6 d-flex flex-column">
                                 <h6 class="text-secondary column-title"><i class="bi bi-list-task me-2"></i>${config[key].t} (${tasks.length})</h6>
                                 <div class="kanban-column flex-grow-1" data-category="${key}" style="min-height: 400px; max-height: 600px; overflow-y: auto;">`;
                     tasks.forEach(task => {
                         // Card representando tarefa do Excel
                         html += `<div class="kanban-card" draggable="true" data-id="${task.ID}"> <!-- ID do Excel -->
                                     <p class="mb-1 small fw-bold">${this.escapeHtml(task['ATIVIDADES'] || 'N/A')}</p>
                                     <small class="text-muted">${this.escapeHtml(task['RESPONSÁVEL'] || 'N/D')}</small>
                                  </div>`;
                     });
                     html += '</div></div>'; // Fecha kanban-column e col-*
                 }
                 this.kanbanExcelContainer.innerHTML = html + '</div>'; // Fecha row g-3

                 // Adiciona listeners APENAS para Drag & Drop
                 this._addManualDragDropListeners(this.kanbanExcelContainer, '.kanban-column', '.kanban-card', handlers);
             }


            // Renderiza Matriz Editável Genérica (usada por Eisenhower e Prós/Contras)
            _renderEditableMatrix(container, matrixData, sections, handlers, matrixType) {
                 if (!container) return;
                 let html = `<div class="row g-3">`;
                 sections.forEach(s => {
                    const items = matrixData[s.id] || [];
                    html += `<div class="col-lg-${12 / sections.length} col-md-6 d-flex flex-column">
                                <div class="analysis-column flex-grow-1 ${s.bgClass || ''}" data-category="${s.id}">
                                    <h6 class="column-title ${s.textClass || ''}" style="border-color: ${s.color};">
                                        <span>${s.title} (${items.length})</span>
                                        <i class="bi bi-plus-circle add-matrix-item" style="cursor:pointer;" data-quadrant="${s.id}" title="Adicionar Item"></i>
                                    </h6>
                                    <div class="items-container" style="max-height: 400px; overflow-y: auto;">
                                        ${items.map(item => `
                                            <div class="manual-item" data-id="${item.id}" draggable="true">
                                                <p class="mb-0 small flex-grow-1 editable-text" contenteditable="true" data-task-id="${item.id}" style="min-height: 20px;">${this.escapeHtml(item.text) || ' '}</p>
                                                <button class="btn btn-sm btn-outline-danger delete-item ms-2 border-0 p-1" data-task-id="${item.id}" data-category="${s.id}" title="Remover Item"><i class="bi bi-x-lg"></i></button>
                                            </div>`).join('')}
                                    </div>
                                </div>
                             </div>`;
                 });
                 html += `</div>`;
                 container.innerHTML = html;

                 // Adiciona listeners (incluindo D&D para itens manuais)
                 container.querySelectorAll('.add-matrix-item').forEach(btn => btn.addEventListener('click', () => handlers.onAdd(btn.dataset.quadrant)));
                 this._addManualEditDeleteListeners(container, handlers, matrixType);
                 this._addManualDragDropListeners(container, '.analysis-column', '.manual-item', handlers);
            }


            renderEisenhower(data, handlers) {
                const quadrants = [ { id: 'important_urgent', title: 'Importante & Urgente', color: '#dc3545', textClass: 'text-danger' }, { id: 'important_not_urgent', title: 'Importante & Não Urgente', color: '#ffc107', textClass: 'text-warning' }, { id: 'not_important_urgent', title: 'Não Importante & Urgente', color: '#0dcaf0', textClass: 'text-info' }, { id: 'not_important_not_urgent', title: 'Não Importante & Não Urgente', color: '#6c757d', textClass: 'text-secondary' } ];
                this._renderEditableMatrix(this.eisenhowerContainer, data, quadrants, handlers, 'eisenhower');
            }

            renderProsCons(data, handlers) {
                 const sections = [ { id: 'pros', title: 'Prós', color: '#198754', textClass: 'pros-title', bgClass: 'pros-column' }, { id: 'contras', title: 'Contras', color: '#dc3545', textClass: 'contras-title', bgClass: 'contras-column' } ];
                 this._renderEditableMatrix(this.prosConsContainer, data, sections, handlers, 'prosCons');
            }


            // Listeners para drag & drop MANUAL (Kanban E Matrizes)
            _addManualDragDropListeners(container, columnSelector, itemSelector, handlers) {
                 if (!container) return;
                 console.log(`Adding D&D listeners to ${container.id} for ${itemSelector} in ${columnSelector}`);
                 const columns = container.querySelectorAll(columnSelector);
                 const items = container.querySelectorAll(itemSelector);

                 // Remove listeners antigos dos itens antes de adicionar novos
                 items.forEach(item => {
                     // Usa funções nomeadas ou propriedades para remover corretamente
                     item.removeEventListener('dragstart', this._handleDragStart);
                     item.removeEventListener('dragend', this._handleDragEnd);
                     item.addEventListener('dragstart', this._handleDragStart.bind(this)); // Bind 'this' se necessário
                     item.addEventListener('dragend', this._handleDragEnd.bind(this));
                 });

                 columns.forEach(column => {
                      // Remove handler antigo associado à coluna
                      const oldDropHandler = column.__dropHandler;
                      if (oldDropHandler) {
                          column.removeEventListener('drop', oldDropHandler);
                      }
                      column.removeEventListener('dragover', this._handleDragOver);
                      column.removeEventListener('dragleave', this._handleDragLeave);

                      // Cria um novo handler wrapper
                      const dropHandler = (e) => this._handleDrop(e, handlers.onDrop);
                      column.__dropHandler = dropHandler; // Guarda referência para remover depois
                      // Adiciona os novos listeners
                     column.addEventListener('dragover', this._handleDragOver);
                     column.addEventListener('dragleave', this._handleDragLeave);
                     column.addEventListener('drop', dropHandler);
                 });
            }
             // --- Funções Helper para Drag & Drop (movidas para View) ---
             _handleDragStart(e) {
                 const draggableElement = e.currentTarget;
                 // Permite arrastar .kanban-card ou .manual-item
                 if (draggableElement.matches('.kanban-card, .manual-item')) {
                     e.dataTransfer.setData('text/plain', draggableElement.dataset.id);
                     e.dataTransfer.effectAllowed = 'move';
                     setTimeout(() => draggableElement.classList.add('dragging'), 0);
                     console.log(`Drag Start: ID=${draggableElement.dataset.id}`);
                 } else { e.preventDefault(); }
             }
             _handleDragEnd(e) { e.currentTarget.classList.remove('dragging'); console.log(`Drag End: ID=${e.currentTarget.dataset.id}`); }
             _handleDragOver(e) { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; e.currentTarget.classList.add('drag-over'); }
             _handleDragLeave(e) { e.currentTarget.classList.remove('drag-over'); }
             _handleDrop(e, onDropCallback) {
                 e.preventDefault(); e.currentTarget.classList.remove('drag-over');
                 const itemId = e.dataTransfer.getData('text/plain');
                 const targetCategory = e.currentTarget.dataset.category;
                 console.log(`Drop Event: ID=${itemId} -> Category=${targetCategory}`);
                 if (itemId && targetCategory && onDropCallback) { onDropCallback(itemId, targetCategory); }
                 else { console.warn("Drop event missing data or callback", {itemId, targetCategory, onDropCallback}); }
             }


             // Listeners para edição e deleção MANUAL (usando delegação de eventos)
             _addManualEditDeleteListeners(container, handlers, toolType) {
                 if (!container) return;
                 console.log(`Adding Edit/Delete listeners (delegated) to ${container.id} for type ${toolType}`);

                 // --- Handler para CLICK (Deleção) ---
                  const clickHandler = (e) => {
                     const deleteButton = e.target.closest('.delete-item');
                     if (deleteButton) {
                         const itemElement = deleteButton.closest('[data-id]'); // O elemento pai com data-id
                         if (itemElement) {
                             const itemId = itemElement.dataset.id;
                             const category = itemElement.closest('[data-category]')?.dataset.category;
                             console.log(`Delete button clicked: ID=${itemId}, Category=${category}, Type=${toolType}`);
                             // Confirmação movida para o Controller
                             handlers.onDelete(category, itemId);
                         }
                     }
                 };
                  // Remove listener antigo se existir e adiciona novo
                 container.removeEventListener('click', container.__clickHandler);
                 container.addEventListener('click', clickHandler);
                 container.__clickHandler = clickHandler;

                // --- Handler para FOCUSIN (Guardar texto original) ---
                const focusinHandler = (e) => {
                    const editableP = e.target.closest('.editable-text');
                     // Verifica se é o elemento correto e se já não tem texto guardado
                    if (editableP && editableP === e.target && !editableP.dataset.originalText) {
                        editableP.dataset.originalText = editableP.innerText;
                        console.log(`Focus In: Stored original text for ${editableP.dataset.taskId}`);
                    }
                };
                 container.removeEventListener('focusin', container.__focusinHandler, true); // Remove antigo (capturing)
                 container.addEventListener('focusin', focusinHandler, true); // Adiciona novo (capturing)
                 container.__focusinHandler = focusinHandler;


                 // --- Handler para FOCUSOUT/BLUR (Salvar Edição) ---
                 const blurHandler = (e) => {
                     const editableP = e.target.closest('.editable-text');
                      // Verifica se é o elemento correto
                     if (editableP && editableP === e.target) {
                         const itemId = editableP.dataset.taskId;
                         const newText = editableP.innerText.trim();
                         const originalText = editableP.dataset.originalText;
                         console.log(`Blur event on item ${itemId}: NewText='${newText}', Original='${originalText}'`);

                         if (itemId) {
                             if (newText && newText !== originalText) {
                                 handlers.onUpdate(itemId, newText); // Chama o update do controller
                             } else if (!newText && originalText) {
                                 editableP.innerText = originalText;
                                 console.log(`Restored original text for ${itemId} (was empty).`);
                             } else {
                                  console.log(`Text unchanged for ${itemId}.`);
                             }
                         } else { console.warn("Blur event on element without data-task-id"); }
                         // Limpa o texto original guardado após o blur
                         delete editableP.dataset.originalText;
                     }
                 };
                  container.removeEventListener('focusout', container.__blurHandler);
                  container.addEventListener('focusout', blurHandler);
                  container.__blurHandler = blurHandler;

                 // --- Handler para KEYDOWN (Salvar com Enter, Cancelar com Escape) ---
                 const keydownHandler = (e) => {
                     const editableP = e.target.closest('.editable-text');
                     if (editableP && editableP === e.target) { // Garante que o evento é no <p>
                         if (e.key === 'Enter') {
                             e.preventDefault();
                             editableP.blur(); // Salva
                         } else if (e.key === 'Escape') {
                             editableP.innerText = editableP.dataset.originalText || ''; // Restaura
                             editableP.blur(); // Cancela e tira foco
                         }
                         // Não precisa guardar original aqui
                     }
                 };
                  container.removeEventListener('keydown', container.__keydownHandler);
                  container.addEventListener('keydown', keydownHandler);
                  container.__keydownHandler = keydownHandler;
             }


            // Renderiza a tabela de dados do Excel
            renderDataTable(data, onDateClick) {
                if (!this.dataTableContainer) return;
                if (!data || data.length === 0) { this.dataTableContainer.innerHTML = '<p class="text-center text-muted mt-3">Nenhum dado para exibir com os filtros atuais.</p>'; return; }

                const headers = ['ORIGEM', 'STATUS', 'ATIVIDADES', 'RESPONSÁVEL', 'PREVISÃO DE TÉRMINO', 'DIAS ÚTEIS', 'TEMPO TOTAL', 'OBSERVAÇÃO'];
                let tableHtml = '<table class="table table-striped table-hover table-sm table-resizable">';
                tableHtml += `<thead class="table-dark sticky-top"><tr>${headers.map(h => `<th>${this.escapeHtml(h)}<div class="resizer"></div></th>`).join('')}</tr></thead><tbody>`;

                data.forEach(row => {
                    tableHtml += `<tr>${headers.map(header => {
                        let value = '', className = '', extra = '';
                        if (header === 'PREVISÃO DE TÉRMINO') {
                            value = this.escapeHtml(row['PREVISÃO DE TÉRMINO_FORMATADA']) || '';
                            if (value && row.ID) {
                                className = 'fw-bold date-cell';
                                extra = `data-activity-id='${this.escapeHtml(row.ID)}' style="cursor: pointer;" title="Clique para ver no calendário"`;
                                if (row.STATUS === 'Pendente' && row.dueDate && row.dueDate < new Date().setHours(0,0,0,0)) {
                                    className += ' table-danger';
                                }
                            }
                        } else {
                            value = row[header] !== undefined && row[header] !== null ? this.escapeHtml(String(row[header])) : '';
                        }
                        if (header === 'DIAS ÚTEIS') {
                            const num = parseInt(row[header], 10);
                            if (!isNaN(num) && num < 0) { className = 'text-danger fw-bold'; }
                        }
                        if (header === 'OBSERVAÇÃO') {
                             const fullObs = String(row[header] || '');
                             if (fullObs.length > 100) {
                                value = this.escapeHtml(fullObs.substring(0, 100)) + '...';
                                extra += ` title="${this.escapeHtml(fullObs).replace(/"/g, '&quot;')}"`;
                             }
                        }
                        return `<td class="${className}" ${extra}>${value}</td>`;
                    }).join('')}</tr>`;
                });

                this.dataTableContainer.innerHTML = tableHtml + '</tbody></table>';
                this.makeTableResizable();

                // Remove listeners antigos antes de adicionar novos
                this.dataTableContainer.querySelectorAll('.date-cell').forEach(cell => {
                    // Remove listener antigo associado a esta célula
                     if (cell.__dateClickHandler) {
                        cell.removeEventListener('click', cell.__dateClickHandler);
                    }
                    // Adiciona o novo listener se tiver ID
                    if (cell.dataset.activityId) {
                         const handler = () => onDateClick(cell.dataset.activityId);
                         cell.addEventListener('click', handler);
                         cell.__dateClickHandler = handler; // Guarda referência para remover depois
                    }
                });
            }

             // Função auxiliar para escapar HTML (evitar XSS)
            escapeHtml(unsafe) {
                if (typeof unsafe !== 'string') return unsafe;
                return unsafe.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
            }


            // Torna as colunas da tabela redimensionáveis
            makeTableResizable() {
                 if (!this.dataTableContainer) return;
                 const thead = this.dataTableContainer.querySelector('thead');
                 if (!thead) return;

                 let currentTh = null; let startX, startWidth;
                 const onMouseMove = (e) => { if (currentTh && startWidth !== null) { const newWidth = startWidth + e.clientX - startX; currentTh.style.width = `${Math.max(newWidth, 50)}px`; } };
                 const onMouseUp = () => { currentTh = null; startWidth = null; window.removeEventListener('mousemove', onMouseMove); window.removeEventListener('mouseup', onMouseUp); document.body.style.cursor = 'default'; };

                 // Remove listener antigo para evitar duplicação
                 thead.removeEventListener('mousedown', thead.__resizerMouseDownHandler);
                 const mouseDownHandler = (e) => {
                     if (e.target.classList.contains('resizer')) {
                         e.preventDefault(); currentTh = e.target.closest('th'); if (!currentTh) return;
                         startX = e.clientX; startWidth = currentTh.offsetWidth;
                         window.addEventListener('mousemove', onMouseMove); window.addEventListener('mouseup', onMouseUp);
                         document.body.style.cursor = 'col-resize';
                     }
                 };
                 thead.addEventListener('mousedown', mouseDownHandler);
                 thead.__resizerMouseDownHandler = mouseDownHandler; // Guarda referência
            }


            // Renderiza os gráficos usando Chart.js
            renderCharts(stats) {
                this._renderPieChart('statusChart', this.statusChartCanvas, ['Pendente', 'Concluído'], [stats.statusCounts.pendente, stats.statusCounts.concluido], ['#ffc107', '#198754']);
                this._renderPieChart('ressalvasChart', this.ressalvasChartCanvas, ['Com Ressalvas', 'Sem Ressalvas'], [stats.ressalvas.com, stats.ressalvas.sem], ['#dc3545', '#0d6efd']);
                this._renderBarChart('responsavelChart', this.responsavelChartCanvas, stats.respChartData);
            }

            // Função auxiliar para renderizar gráficos de pizza
            _renderPieChart(id, canvas, labels, data, colors) {
                if (!canvas) { console.warn(`Canvas element with ID "${id}" not found.`); return; }
                if (this.charts[id]) { this.charts[id].destroy(); }
                try {
                     this.charts[id] = new Chart(canvas, { type: 'pie', data: { labels, datasets: [{ data, backgroundColor: colors }] }, options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } } } });
                     console.log(`Rendered pie chart: ${id}`);
                } catch (error) { console.error(`Error rendering pie chart "${id}":`, error); }
            }

            // Função auxiliar para renderizar gráficos de barra empilhados
            _renderBarChart(id, canvas, data) {
                 if (!canvas) { console.warn(`Canvas element with ID "${id}" not found.`); return; }
                 if (this.charts[id]) { this.charts[id].destroy(); }
                 try {
                    const labels = Object.keys(data);
                    const pendenteData = labels.map(l => data[l]?.Pendente || 0);
                    const concluidoData = labels.map(l => data[l]?.Concluído || 0);
                    this.charts[id] = new Chart(canvas, { type: 'bar', data: { labels, datasets: [ { label: 'Pendente', data: pendenteData, backgroundColor: '#ffc107' }, { label: 'Concluído', data: concluidoData, backgroundColor: '#198754' } ] }, options: { responsive: true, maintainAspectRatio: false, scales: { x: { stacked: true }, y: { stacked: true, beginAtZero: true } }, plugins: { tooltip: { mode: 'index', intersect: false } } } });
                     console.log(`Rendered bar chart: ${id}`);
                 } catch (error) { console.error(`Error rendering bar chart "${id}":`, error); }
            }

            // Alterna a visibilidade das diferentes "views"
            switchView(targetViewId) {
                console.log(`Switching view to: ${targetViewId}`);
                let foundView = false;
                document.querySelectorAll('.view-container').forEach(div => {
                    if (div.id === targetViewId) { div.classList.remove('d-none'); foundView = true; }
                    else { div.classList.add('d-none'); }
                });
                if (!foundView) { console.error(`View container "${targetViewId}" not found!`); document.getElementById('main-dashboard-view')?.classList.remove('d-none'); targetViewId = 'main-dashboard-view'; }
                document.querySelectorAll('.nav-link[data-view]').forEach(item => item.classList.remove('active'));
                const activeLink = document.querySelector(`.nav-link[data-view="${targetViewId}"]`);
                if(activeLink) { activeLink.classList.add('active'); }
                else { console.warn(`Nav link for view "${targetViewId}" not found.`); }
            }
        }

        // --- CONTROLLER (App Logic) ---
        class AppController {
            constructor(model, view) {
                this.model = model;
                this.view = view;
                this.modal = new bootstrap.Modal(document.getElementById('calendarModal'));
                this.currentView = 'main-dashboard-view'; // View inicial
            }


            // Inicializa a aplicação
            init() {
                console.log("Initializing AppController...");
                this.view.toggleLoading(true);
                const stateLoaded = this.model.loadState();
                this.setupEventListeners(); // Configura listeners GLOBAIS

                if (!this.view.initialMessage || !this.view.dashboardViewContent) {
                     console.error("View elements not ready!"); this.view.getElements();
                     if (!this.view.initialMessage || !this.view.dashboardViewContent) {
                         alert("Erro crítico: Interface não inicializada."); this.view.toggleLoading(false); return;
                     }
                }

                const hasSavedExcelData = stateLoaded && this.model.excelData.all && this.model.excelData.all.length > 0;

                if (hasSavedExcelData) {
                    console.log("Previous Excel data found, populating...");
                    this.view.populateFilters(this.model.excelData.sheetNames, this.model.getUniqueResponsibles());
                    this.model.applyFilters({}); // Aplica filtro padrão
                    this.view.toggleDashboardContentVisibility(true); // Mostra dashboard
                    this.view.exportButton.disabled = false;
                } else {
                    console.log("No previous Excel data. Waiting for file upload.");
                     this.view.toggleDashboardContentVisibility(false); // Mostra msg inicial
                    this.view.populateFilters([], []); // Filtros vazios
                }

                this.updateDashboard(); // Renderiza a view inicial
                this.view.toggleLoading(false);
                console.log("Initialization complete.");
            }

            // Configura os listeners de eventos GLOBAIS da interface
            setupEventListeners() {
                console.log("Setting up global event listeners...");
                 const fileInput = document.getElementById('file-input');
                 if(fileInput) fileInput.addEventListener('change', e => this.handleFileSelect(e));

                [this.view.sheetSelector, this.view.responsavelFilter, this.view.statusGeralFilter, this.view.ressalvaFilter].forEach(el => {
                     if(el) el.addEventListener('change', () => this.handleFilterChange());
                });
                if(this.view.sidebarToggle) this.view.sidebarToggle.addEventListener('click', () => {
                     if(this.view.sidebar) this.view.sidebar.classList.toggle('active');
                });
                if(this.view.exportButton) this.view.exportButton.addEventListener('click', () => this.handleExport());

                document.querySelectorAll('[data-view]').forEach(item => {
                    item.addEventListener('click', (e) => {
                        e.preventDefault();
                        const newView = e.currentTarget.dataset.view;
                        if (newView !== this.currentView) {
                            console.log(`Navigation clicked: changing view to ${newView}`);
                            this.currentView = newView;
                            this.updateDashboard();
                        }
                    });
                });

                // Botão Adicionar Tarefa Kanban (REMOVIDO)
                // const addKanbanBtn = document.getElementById('add-kanban-task-btn');
                // if (addKanbanBtn) addKanbanBtn.addEventListener('click', () => this.handleKanbanAddItem());

                console.log("Global event listeners set up.");
            }

            // Manipula a seleção de um novo arquivo
            async handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) { console.log("File selection cancelled."); return; }
                console.log(`File selected: ${file.name}`);
                this.view.toggleLoading(true);
                this.view.updateFileName(file.name);
                try {
                    await this.model.loadWorkbook(file);
                    this.model.saveState(); // Salva estado (inclui dados do excel e nome)
                    this.view.populateFilters(this.model.excelData.sheetNames, this.model.getUniqueResponsibles());
                    this.handleFilterChange(); // Aplica filtros e atualiza a UI (que vai chamar updateDashboard)
                } catch (error) {
                    console.error("Error loading workbook:", error);
                    alert(`Erro ao carregar o arquivo "${file.name}":\n${error.message}\nVerifique o formato.`);
                    const stateLoaded = this.model.loadState(); // Tenta recarregar estado anterior
                     const fileNameEl = document.getElementById('file-name');
                     if (fileNameEl) { fileNameEl.textContent = this.model.excelData.fileName; } // Restaura nome do arquivo do modelo
                    // Limpa dados do Excel no modelo se o carregamento falhou
                    this.model.excelData = { all: [], filtered: [], sheetNames: [], fileName: this.model.excelData.fileName };
                    this.view.populateFilters([], []); // Limpa filtros da UI
                    this.handleFilterChange(); // Atualiza UI para refletir falha
                } finally {
                    this.view.toggleLoading(false);
                }
            }

            // Manipula a mudança nos filtros
            handleFilterChange() {
                 console.log("Filter change detected.");
                 if (this.model.excelData.all && this.model.excelData.all.length > 0) {
                     console.log("Applying filters...");
                    this.model.applyFilters({
                        sheet: this.view.sheetSelector.value,
                        responsible: this.view.responsavelFilter.value,
                        status: this.view.statusGeralFilter.value,
                        ressalva: this.view.ressalvaFilter.value,
                    });
                     // Re-renderiza a view atual se ela depender dos filtros
                    if (this.currentView === 'main-dashboard-view' || this.currentView === 'kanban-view') {
                        this.updateDashboard();
                    }
                 } else {
                     console.log("No Excel data loaded, filter change ignored for rendering.");
                     if(this.currentView === 'main-dashboard-view') this.view.toggleDashboardContentVisibility(false);
                     if(this.currentView === 'kanban-view' && this.view.kanbanExcelContainer) this.view.kanbanExcelContainer.innerHTML = '<p class="text-muted text-center">Carregue um arquivo Excel/CSV.</p>';
                 }
            }

            // Atualiza a interface com base na view atual e nos dados do modelo
            updateDashboard() {
                 console.log(`Updating dashboard UI for view: ${this.currentView}`);
                 this.view.switchView(this.currentView); // Garante que a view correta está visível

                 try {
                    // Lógica de renderização específica para cada view
                    if (this.currentView === 'main-dashboard-view') {
                        const hasExcelData = this.model.excelData.all && this.model.excelData.all.length > 0;
                        this.view.toggleDashboardContentVisibility(hasExcelData);
                        if (hasExcelData) {
                            const stats = this.model.getStats(); // Recalcula stats
                            this.view.renderStatsCards(stats);
                            this.view.renderCharts(stats);
                            this.view.renderDataTable(this.model.excelData.filtered, id => this.handleDateClick(id));
                        }
                    } else if (this.currentView === 'kanban-view') {
                        // Renderiza Kanban com dados PENDENTES do Excel FILTRADO e handlers
                         // Prepara os dados agrupados por categoria salva ou 'todo'
                         const tasks = this.model.excelData.filtered.filter(task => task.STATUS === 'Pendente');
                         const groupedTasks = { todo: [], inprogress: [], done: [] }; // done sempre vazio
                         tasks.forEach(task => {
                             const category = task._kanbanCategory || 'todo';
                             if (groupedTasks[category]) {
                                 groupedTasks[category].push(task);
                             } else {
                                 groupedTasks.todo.push(task); // Fallback
                             }
                         });

                        this.view.renderKanbanExcel(groupedTasks, { // Passa dados agrupados
                            onDrop: (id, cat) => this.handleKanbanDrop(id, cat)
                        });
                        this.view.toggleDashboardContentVisibility(false); // Esconde conteúdo do dashboard principal
                    } else if (this.currentView === 'eisenhower-view') {
                        this.view.renderEisenhower(this.model.getAnalysisData().eisenhower, {
                           onAdd: (q) => this.handleMatrixAddItem('eisenhower', q),
                           onUpdate: (itemId, newText) => this.handleMatrixUpdateItem('eisenhower', null, itemId, newText),
                           onDelete: (category, itemId) => this.handleMatrixDeleteItem('eisenhower', category, itemId),
                           onDrop: (itemId, targetCategory) => this.handleMatrixDrop('eisenhower', itemId, targetCategory)
                        });
                        this.view.toggleDashboardContentVisibility(false);
                    } else if (this.currentView === 'swot-view') {
                         this.view.renderProsCons(this.model.getAnalysisData().prosCons, {
                           onAdd: (category) => this.handleMatrixAddItem('prosCons', category),
                           onUpdate: (itemId, newText) => this.handleMatrixUpdateItem('prosCons', null, itemId, newText),
                           onDelete: (category, itemId) => this.handleMatrixDeleteItem('prosCons', category, itemId),
                           onDrop: (itemId, targetCategory) => this.handleMatrixDrop('prosCons', itemId, targetCategory)
                        });
                        this.view.toggleDashboardContentVisibility(false);
                    }
                 } catch (error) {
                     console.error(`Error during dashboard update for view ${this.currentView}:`, error);
                     alert("Ocorreu um erro ao atualizar a visualização. Verifique o console.");
                 }
                 // Habilita/desabilita botão Exportar baseado se há *qualquer* dado
                 const hasExcelDataForExport = this.model.excelData.all && this.model.excelData.all.length > 0;
                 const hasManualData = Object.values(this.model.eisenhowerState).some(arr => arr.length > 0) ||
                                      Object.values(this.model.prosConsState).some(arr => arr.length > 0);
                 if (this.view.exportButton) this.view.exportButton.disabled = !(hasExcelDataForExport || hasManualData);


                 console.log("Dashboard UI update complete.");
            }

            // --- Handlers para Ferramentas ---

            // ** KANBAN (EXCEL) **
            handleKanbanDrop(taskId, targetColumnName) {
                console.log(`Kanban Drop (Excel Task): ID='${taskId}', Target='${targetColumnName}'`);
                const newStatus = (targetColumnName === 'done') ? 'Concluído' : 'Pendente';
                 // Define a categoria Kanban apenas se o novo status for Pendente
                 const newKanbanCategory = (newStatus === 'Pendente') ? targetColumnName : null;

                // Atualiza o status e a categoria no modelo de dados do Excel
                const statusChanged = this.model.updateExcelActivityStatus(taskId, newStatus, newKanbanCategory);

                // Re-renderiza o Kanban para refletir a mudança visualmente,
                // mesmo que o status não tenha mudado (pode ter mudado de coluna pendente)
                this.updateDashboard();

                // Se o status mudou, e estávamos no Dashboard, força atualização dele também
                if (statusChanged && this.currentView === 'main-dashboard-view') {
                    // Força re-aplicação dos filtros e re-render do dashboard
                    this.handleFilterChange();
                }
            }

            // ** MATRIZES MANUAIS **
            handleMatrixAddItem(matrixType, category) {
                const text = prompt(`Adicionar item para ${category.replace('_', ' ')} (${matrixType}):`);
                if (!text || text.trim() === "") return;
                this.model.addManualItem(matrixType, category, text.trim());
                this.updateDashboard(); // Re-renderiza a matriz correspondente
            }
            handleMatrixUpdateItem(matrixType, categoryIgnored, itemId, newText) {
                this.model.updateManualItem(matrixType, itemId, newText);
                // Não precisa re-renderizar tudo, o blur salva
            }
            handleMatrixDeleteItem(matrixType, category, itemId) {
                if (!confirm("Tem certeza que deseja apagar este item da matriz?")) return;
                if (this.model.removeManualItem(matrixType, category, itemId)) {
                    this.updateDashboard(); // Re-renderiza a matriz
                }
            }
            // Handler para drop DENTRO das matrizes manuais
            handleMatrixDrop(matrixType, itemId, targetCategory) {
                 console.log(`Matrix Drop: Type=${matrixType}, ID='${itemId}', Target='${targetCategory}'`);
                 if(this.model.moveManualItem(matrixType, itemId, targetCategory)) {
                     this.updateDashboard(); // Re-renderiza a matriz
                 }
            }


            // Manipula a exportação de dados para Excel
            handleExport() {
                 console.log("Export button clicked.");
                this.view.toggleLoading(true);
                try {
                    const workbook = XLSX.utils.book_new();
                    let hasDataToExport = false;

                    // 1. Aba de dados do Excel (com status atualizado pelo Kanban)
                    if(this.model.excelData.all && this.model.excelData.all.length > 0) {
                        console.log(`Exporting ${this.model.excelData.all.length} rows from Excel data.`);
                        const excelExportData = this.model.excelData.all.map(row => {
                            const { ID, ORIGEM, dueDate, _kanbanCategory, ...rest } = row; // Remove props internas
                            if(rest['PREVISÃO DE TÉRMINO_FORMATADA']) { rest['PREVISÃO DE TÉRMINO'] = rest['PREVISÃO DE TÉRMINO_FORMATADA']; }
                            delete rest['PREVISÃO DE TÉRMINO_FORMATADA'];
                            return rest;
                        });
                        const excelSheet = XLSX.utils.json_to_sheet(excelExportData);
                        XLSX.utils.book_append_sheet(workbook, excelSheet, "Dados Atividades");
                        hasDataToExport = true;
                    } else { console.log("No Excel data to export."); }

                    // 2. Abas das Matrizes Manuais
                    const eisenhowerExport = [];
                    Object.entries(this.model.eisenhowerState).forEach(([q, items]) => { (items || []).forEach(item => eisenhowerExport.push({ Quadrante: q.replace('_', ' ').replace(/\b\w/g, c => c.toUpperCase()), Item: item.text })); });
                     if(eisenhowerExport.length > 0) {
                        console.log(`Exporting ${eisenhowerExport.length} Eisenhower items.`);
                        const eisenhowerSheet = XLSX.utils.json_to_sheet(eisenhowerExport);
                        XLSX.utils.book_append_sheet(workbook, eisenhowerSheet, "Matriz Eisenhower");
                        hasDataToExport = true;
                    } else { console.log("No Eisenhower data to export."); }

                    const prosConsExport = [];
                     Object.entries(this.model.prosConsState).forEach(([col, items]) => { (items || []).forEach(item => prosConsExport.push({ Tipo: col.toUpperCase(), Item: item.text })); });
                     if(prosConsExport.length > 0) {
                        console.log(`Exporting ${prosConsExport.length} Pros/Cons items.`);
                        const prosConsSheet = XLSX.utils.json_to_sheet(prosConsExport);
                        XLSX.utils.book_append_sheet(workbook, prosConsSheet, "Prós e Contras");
                        hasDataToExport = true;
                    } else { console.log("No Pros/Cons data to export."); }

                    // Gera o arquivo
                    if(hasDataToExport) {
                        XLSX.writeFile(workbook, "Dashboard_Completo_Exportado.xlsx");
                        console.log("Export successful.");
                    } else {
                        alert("Não há dados para exportar.");
                        console.log("Export cancelled, no data found.");
                    }

                } catch(e) { console.error("Error exporting data:", e); alert(`Erro na exportação:\n${e.message}`); }
                finally { this.view.toggleLoading(false); }
            }

            // Manipula o clique na data da tabela
            handleDateClick(activityId) {
                 console.log(`Date cell clicked for activity ID: ${activityId}`);
                const activity = this.model.excelData.all.find(a => a.ID === activityId);
                if (!activity) { console.warn("Activity not found."); return; }
                if (!activity.dueDate) { alert(`A atividade "${activity['ATIVIDADES']}" não possui data.`); return; }
                const activitiesInMonth = this.model.getActivitiesForMonth(activity.dueDate);
                console.log(`Found ${activitiesInMonth.length} activities for the calendar.`);
                this.renderCalendarModal(activity.dueDate, activitiesInMonth);
                this.modal.show();
            }

            // Renderiza o conteúdo do modal de calendário
            renderCalendarModal(date, activities) {
                 const calendarContainer = document.getElementById('calendar-container');
                 const detailsContainer = document.getElementById('modal-activity-details');
                 if (!calendarContainer || !detailsContainer) return;

                const render = (dayOfMonth) => {
                    calendarContainer.innerHTML = this.generateCalendarHTML(date, activities, dayOfMonth);
                    calendarContainer.querySelectorAll('.has-activity').forEach(cell => {
                        cell.addEventListener('click', e => render(parseInt(e.currentTarget.textContent)) );
                    });
                    this.updateModalDetails(detailsContainer, activities.filter(a => a.dueDate && a.dueDate.getDate() === dayOfMonth));
                }
                render(date.getDate());
            }

            // Gera o HTML da tabela do calendário
            generateCalendarHTML(date, activitiesForMonth, selectedDay) {
                const month = date.getMonth(), year = date.getFullYear();
                const monthNames = ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];
                const dayNames = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"];
                const firstDayOfMonth = new Date(year, month, 1).getDay(); const daysInMonth = new Date(year, month + 1, 0).getDate();
                let html = `<h4 class="text-center mb-3">${monthNames[month]} de ${year}</h4>`;
                html += '<table class="table table-bordered text-center table-sm"><thead><tr>' + dayNames.map(d => `<th>${d}</th>`).join('') + '</tr></thead><tbody>';
                let day = 1;
                for (let i = 0; i < 6; i++) {
                    html += '<tr>';
                    for (let j = 0; j < 7; j++) {
                        if ((i === 0 && j < firstDayOfMonth) || day > daysInMonth) { html += '<td></td>'; }
                        else {
                            let cellClass = 'calendar-day';
                            if (activitiesForMonth.some(a => a.dueDate && a.dueDate.getDate() === day)) { cellClass += ' has-activity'; if (day === selectedDay) { cellClass += ' selected-day'; } }
                            html += `<td class="${cellClass}">${day++}</td>`;
                        }
                    } html += '</tr>'; if (day > daysInMonth) break;
                }
                return html + '</tbody></table>';
            }

            // Atualiza a área de detalhes no modal do calendário
            updateModalDetails(container, activities) {
                 if (!container) return;
                if (!activities || activities.length === 0) { container.innerHTML = '<p class="text-muted text-center">Nenhuma atividade para este dia.</p>'; return; }
                container.innerHTML = activities.map((activity, index) => `
                    ${index > 0 ? '<hr class="my-2">' : ''}
                    <p class="mb-1"><strong>Atividade:</strong> ${this.view.escapeHtml(activity['ATIVIDADES']) || 'N/A'}</p>
                    <div class="d-flex justify-content-between flex-wrap small">
                        <span class="me-3"><strong>Responsável:</strong> ${this.view.escapeHtml(activity['RESPONSÁVEL']) || 'N/D'}</span>
                        <span class="me-3"><strong>Status:</strong> <span class="badge ${activity.STATUS === 'Concluído' ? 'bg-success' : 'bg-warning text-dark'}">${this.view.escapeHtml(activity.STATUS) || 'N/A'}</span></span>
                        <span class="me-3"><strong>Dias Úteis:</strong> ${activity['DIAS ÚTEIS'] !== null && activity['DIAS ÚTEIS'] !== undefined ? activity['DIAS ÚTEIS'] : 'N/A'}</span>
                        <span class="me-3"><strong>Tempo Total:</strong> ${this.view.escapeHtml(activity['TEMPO TOTAL']) || 'N/A'}</span>
                    </div>
                    <p class="mb-0 mt-1 small"><strong>Observação:</strong> ${this.view.escapeHtml(activity['OBSERVAÇÃO']) || 'Nenhuma'}</p>
                `).join('');
            }
        }

        // --- INICIALIZAÇÃO DA APLICAÇÃO ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM fully loaded. Initializing application...");
            try {
                const model = new DataModel();
                const view = new DashboardView();
                const controller = new AppController(model, view);
                controller.init(); // Inicia o controller
            } catch (error) {
                 console.error("Critical error during application initialization:", error);
                 document.body.innerHTML = `<div class="alert alert-danger m-5"><h4>Erro Crítico!</h4><p>Falha ao iniciar: ${error.message}. Verifique o console (F12).</p></div>`;
            }
        });
    </script>
</body>
</html>

